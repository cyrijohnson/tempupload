import React, { useState, useEffect } from "react";
import { TextField, MenuItem, Grid, Button, Typography } from "@mui/material";
import isEqual from "lodash.isequal";

/**
 * Expects input in the form of an array of objects with the following structure:
 * [
 *   {
 *     name: string,
 *     label: string,
 *     type: string ("text", "select", "number", "button"),
 *     selected: Object,
 *     options: Array (objects in the array must have a 'name' and an 'id' property)
 *   },
 *   {
 *     ...
 *   }
 * ]
 * Returns an array of objects with the following structure:
 * [
 *   {
 *     name: string,
 *     selected: Object,
 *   },
 *   {
 *   ...
 *   }
 * ]
 */

/**
 * Example:
 * <AutoGeneratedFieldGroup
 *   data={selectedOrderItem.attributes.categories.map(
 *     (category) => {
 *       return {
 *         name: category,
 *         type: category.type,
 *         options: category.options,
 *       };
 *     }
 *   )}
 * />
 */

export default function AutoGeneratedFieldGroup({
  data,
  alwaysRefresh,
  onChange,
}) {
  const [modifiedData, setModifiedData] = useState([]);
  const [initialized, setInitialized] = useState(false);

  // input sanitation check
  useEffect(() => {
    if (!alwaysRefresh && modifiedData.length != 0) return;
    let toUpdate = data;
    toUpdate.forEach((item) => {
      switch (item.type) {
        case "text":
          if (!item.selected) item.selected = item.name;
          break;
        case "number":
          if (!item.selected) item.selected = 0;
          break;
        case "select":
          if (!item.selected) item.selected = item.options[0].id;
          break;
        case "button":
          if (!item.selected) item.selected = item.options[0];
          break;
        default:
          if (!item.selected) item.selected = item.name;
          break;
      }
    });

    // console.log("toUpdate", toUpdate);
    if (!isEqual(modifiedData, toUpdate)) {
      setModifiedData(toUpdate);
    }
    setInitialized(true);
  }, [data]);

  // output generation
  const sanitizeOutput = (input) => {
    let toReturn = [];
    input.forEach((item, index) => {
      switch (item.type) {
        case "select":
          let selectedItem = input[index].options.find(
            (option) => option.id == item.selected
          );
          toReturn.push({
            name: item.name,
            selected: selectedItem,
          });
          break;

        default:
          toReturn.push({
            name: item.name,
            selected: item.selected,
          });
          break;
      }
    });
    return toReturn;
  };

  // return output on change
  useEffect(() => {
    let toReturn = sanitizeOutput(modifiedData);
    if (
      toReturn.length == 0 ||
      (toReturn.length > 0 &&
        !toReturn.every((item) => item.hasOwnProperty("selected")))
    )
      return;

    // console.log("init", initialized);
    if (onChange && initialized) onChange(toReturn);
  }, [modifiedData]);

  if (modifiedData.length == 0) {
    return <Typography variant="body1">Loading...</Typography>;
  }

  return (
    <>
      {data.map((item, index) => (
        <Grid container key={index} sx={{ minWidth: "3em" }}>
          {item.type == "text" && (
            <Grid item xs={12} sx={{ mb: 3 }}>
              <TextField
                label={item.label ?? item.name}
                value={modifiedData[index].selected}
                onChange={(e) => {
                  let newData = [...modifiedData];
                  newData[index].selected = e.target.value;
                  setModifiedData(newData);
                }}
                fullWidth
                size="small"
                variant="standard"
              />
            </Grid>
          )}
          {item.type == "number" && (
            <Grid item xs={12} sx={{ mb: 3 }}>
              <TextField
                label={item.label ?? item.name}
                value={modifiedData[index].selected}
                onChange={(e) => {
                  let newData = [...modifiedData];
                  newData[index].selected = e.target.value;
                  setModifiedData(newData);
                }}
                fullWidth
                type="number"
                size="small"
                variant="standard"
              />
            </Grid>
          )}
          {item.type == "select" && (
            <Grid item xs={12} sx={{ mb: 3 }}>
              <TextField
                name={item.name}
                label={item.label ?? item.name}
                value={modifiedData[index].selected}
                fullWidth
                select
                onChange={(e) => {
                  let newData = [...modifiedData];
                  newData[index].selected = e.target.value;
                  setModifiedData(newData);
                }}
              >
                {item.options.map((option) => (
                  <MenuItem value={option.id} key={option.id}>
                    {option.name ?? option.content}
                  </MenuItem>
                ))}
              </TextField>
            </Grid>
          )}
          {item.type == "button" && (
            <Grid item xs={12} sx={{ mb: 3 }}>
              <Typography variant="body1">{item.label ?? item.name}</Typography>
              {item.options.map((option, ind) => (
                <Button
                  key={ind}
                  color={
                    modifiedData[index].selected == option
                      ? "primary"
                      : "inherit"
                  }
                  onClick={() => {
                    let newData = [...modifiedData];
                    newData[index].selected = option;
                    setModifiedData(newData);
                  }}
                >
                  {option.name ?? option.content}
                </Button>
              ))}
            </Grid>
          )}
        </Grid>
      ))}
    </>
  );
}
